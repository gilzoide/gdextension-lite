#!/bin/env python
"""
GDExtension C binding generator script

Given the path to `extension_api.json` file generated by Godot 4, it writes
several header files with generated bindings in the given output directory.

Usage:
    binding_generator.py EXTENSION_API_PATH OUTPUT_DIR
"""

import json
import sys

from builtin_classes.generator import generate_builtin_class, generate_initialize_all_builtin_classes, generate_variant, generate_variant_sizes
from classes.generator import generate_class_stub_header, generate_all_class_stubs, generate_class_method_header, generate_initialize_all_classes
from enums import generate_all_enums
from extension_interface import generate_all_extension_bindings
from format_utils import format_type_snake_case
from header import CodeWriter
from json_types import ArgumentOrSingletonOrMember, Class, ExtensionApi
from native_structures import generate_all_native_structures
from utility_functions import generate_utility_functions


def _get_class_singleton_name(
    cls: Class,
    singletons: list[ArgumentOrSingletonOrMember],
) -> ArgumentOrSingletonOrMember | None:
    for singleton in singletons:
        if singleton["type"] == cls["name"]:
            return singleton
    return None


def main():
    if len(sys.argv) < 3:
        sys.stderr.write(__doc__.lstrip())
        sys.exit(-1)

    extension_api_path = sys.argv[1]
    output_dir = sys.argv[2]

    with open(extension_api_path, 'r') as file:
        extension_api: ExtensionApi = json.load(file)
    code_writer = CodeWriter(*output_dir.split("/"))

    # Global Enums
    code_writer.write_file(
        generate_all_enums(extension_api["global_enums"]),
        "global_enums",
    )

    # Extension Interface
    code_writer.write_file(
        generate_all_extension_bindings(),
        "extension_interface",
    )

    # Builtin Classes (a.k.a Variants)
    builtin_classes = [
        cls
        for cls in extension_api["builtin_classes"]
        if cls["name"] != "Nil"
    ]
    for builtin_class in builtin_classes:
        code_writer.write_file(
            generate_builtin_class(builtin_class),
            "variant", format_type_snake_case(builtin_class["name"]),
        )
    code_writer.write_file(
        generate_variant(builtin_classes),
        "variant", "variant",
    )
    code_writer.write_file(
        generate_initialize_all_builtin_classes(builtin_classes),
        "variant", "all",
    )

    code_writer.write_file(
        generate_variant_sizes(extension_api["builtin_class_sizes"]),
        "variant", "sizes"
    )

    # Utility functions
    code_writer.write_file(
        generate_utility_functions(extension_api["utility_functions"]),
        "utility_functions",
    )

    # Native Structures
    contents = generate_all_native_structures(extension_api["native_structures"])
    code_writer.write_file(contents, "native_structures")

    # Classes
    for cls in extension_api["classes"]:
        code_writer.write_file(
            generate_class_stub_header(cls),
            "class-stubs", format_type_snake_case(cls["name"]),
        )
        code_writer.write_file(
            generate_class_method_header(cls, _get_class_singleton_name(cls, extension_api["singletons"])),
            "class-methods", format_type_snake_case(cls["name"]),
        )
    code_writer.write_file(
        generate_all_class_stubs(extension_api["classes"]),
        "class-stubs", "all",
    )
    code_writer.write_file(
        generate_initialize_all_classes(extension_api["classes"]),
        "class-methods", "all",
    )


if __name__ == "__main__":
    main()
